package com.twjitm.transaction.lock;import com.twjitm.transaction.service.redis.NettyTransactionRedisService;import com.twjitm.transaction.transaction.enums.NettyTransactionEntityCause;import com.twjitm.transaction.transaction.enums.NettyTransactionLockStateEnum;import com.twjitm.transaction.transaction.exception.NettyTransactionException;import com.twjitm.transaction.utils.TimeUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * netty 事物锁，基于redis实现 * <pre> * 写锁 * </pre> * * @author twjitm - [Created on 2018-08-27 12:05] * @company https://github.com/twjitm * @jdk java version "1.8.0_77" */public class NettyTransactionLock implements NettyTransactionLockInterface {    private Logger logger = LoggerFactory.getLogger(NettyTransactionLock.class);    /**     * 事物锁关键字     */    private String lockKey;    /**     * 事物锁创建需要的redis服务     */    private NettyTransactionRedisService redisService;    /**     * 事务支出的zookeeper服务器     *     *     */    /**     * 事物产生实体的原因     */    private NettyTransactionEntityCause cause;    /**     * 事物锁状态     */    private NettyTransactionLockStateEnum lockStateEnum;    /**     * 锁时长     */    private int lockTime;    /**     * 锁强制标识     */    private boolean forceFlag;    /**     * 锁内容     */    private String lockContext = "";    /**     * 初始化一个写锁，默认锁时间为系统配置时间。     *     * @param lockKey     * @param redisService     * @param cause     */    public NettyTransactionLock(String lockKey, NettyTransactionRedisService redisService, NettyTransactionEntityCause cause) {        super();        this.lockKey = lockKey;        this.redisService = redisService;        this.cause = cause;        this.lockStateEnum = NettyTransactionLockStateEnum.INIT;        this.lockTime = TimeUtil.MINUTE_SECOND;    }    /**     * 初始化一个写锁。并且指定锁时间，是否具有强制性。     *     * @param lockKey     * @param redisService     * @param cause     * @param lockTime     * @param forceFlag     */    public NettyTransactionLock(String lockKey, NettyTransactionRedisService redisService, NettyTransactionEntityCause cause, int lockTime, boolean forceFlag) {        super();        this.lockKey = lockKey;        this.redisService = redisService;        this.cause = cause;        this.lockStateEnum = NettyTransactionLockStateEnum.INIT;        this.lockTime = lockTime;        this.forceFlag = forceFlag;    }    /**     * 初始化一个具有内容的写锁，并且制定锁时间和强制性标志。以及所内容     *     * @param lockKey     * @param redisService     * @param cause     * @param lockTime     * @param forceFlag     * @param lockContext     */    public NettyTransactionLock(String lockKey, NettyTransactionRedisService redisService, NettyTransactionEntityCause cause, int lockTime, boolean forceFlag, String lockContext) {        super();        this.lockKey = lockKey;        this.redisService = redisService;        this.cause = cause;        this.lockStateEnum = NettyTransactionLockStateEnum.INIT;        this.lockTime = lockTime;        this.forceFlag = forceFlag;        this.lockContext = lockContext;    }    /**     * <p>     * 注销一个锁。     * 锁的注销是有条件的。锁不能再初始化的时候和创建的时候注销。     * 只能这个锁创建成功后才能注销。创建一个锁。将必须使用这个锁。若创建一个锁不进行使用     * 的话，将无法注销这个锁。只能等锁时间过期后才能自动注销锁     * </p>     */    @Override    public void destroy() {        if (this.lockStateEnum.equals(NettyTransactionLockStateEnum.INIT) ||                this.lockStateEnum.equals(                        NettyTransactionLockStateEnum.CREATE)) {            return;        }        boolean destroyFlag = true;        if (!lockContext.equals("".trim())) {            destroyFlag = checkLockContext();        }        String realLockKey = getLockKey(lockKey, cause);        if (destroyFlag) {            boolean delete = redisService.deleteKey(realLockKey);            if (!delete) {                logger.info("居然没有删除掉这个key=" + realLockKey);            }        }    }    /**     * 检测锁内容     *     * @return     */    private boolean checkLockContext() {        boolean checkFlag = false;        String content = redisService.getString(getLockKey(lockKey, cause));        if (content != null) {            checkFlag = content.equals(this.lockContext);        }        return checkFlag;    }    /**     * 获取锁可以     *     * @param lockKey     * @param cause     * @return     */    public String getLockKey(String lockKey, NettyTransactionEntityCause cause) {        return lockKey + "#" + cause.getCause();    }    /**     * 创建分布式事物锁，创建一个分布式事物锁的代价是比较高的，     * 应为需要将请求消息发送到对应的redis服务器或者是zookeeper服务器     * 但是当我们逻辑服务器和redis不在同一台服务器的时候，我们需要走网络层     * 连接，相当于开启一个tcp连接通道。这条通道主要是为了我们能够与redis或者zookeeper     * 服务器进行通讯，为可防止单点问题，我们可以将redis做成集群模式，同样zookeeper也     * 一样。当然在这个地方我们默认使用redis实现分布式所务锁，当别的逻辑服务器申请锁的     * 的时候也会进行创建。利用redis的原子性，保证本锁的原子性。     *     * @param seconds     * @return     * @throws NettyTransactionException     */    @Override    public boolean create(long seconds) throws NettyTransactionException {        this.lockStateEnum = NettyTransactionLockStateEnum.CREATE;        boolean createFlag;        String realLockKey = getLockKey(lockKey, cause);        try {            //设置锁标识            createFlag = redisService.setNxString(realLockKey, lockContext, lockTime);            if (createFlag) {                this.lockStateEnum = NettyTransactionLockStateEnum.SUCCESS;                logger.info("创建锁成功");                redisService.expire(realLockKey, lockTime);            } else {                if (forceFlag) {                    this.lockStateEnum = NettyTransactionLockStateEnum.SUCCESS;                    redisService.setString(realLockKey, lockContext, lockTime);                    redisService.expire(realLockKey, lockTime);                    createFlag = true;                    logger.info("创建强制锁:" + realLockKey + ",过期时间长度为: " + lockTime);                } else {                    createFlag = false;                    logger.info("创建锁失败" + realLockKey + ",过期时间为: " + lockTime);                }            }        } catch (Exception e) {            throw new NettyTransactionException("创建锁发生意想不到的错误，请检查");        }        return createFlag;    }    @Override    public String getInfo() {        return lockKey + cause + checkLockContext() + lockTime;    }    @Override    public void setContent(String lockContent) {        this.lockContext = lockContent;    }}