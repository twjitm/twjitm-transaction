package com.twjitm.transaction.transaction;import com.twjitm.transaction.config.GlobalConstants;import com.twjitm.transaction.transaction.entity.NettyTransactionEntityInterface;import com.twjitm.transaction.transaction.enums.NettyTransactionCause;import com.twjitm.transaction.transaction.enums.NettyTransactionCommitResult;import com.twjitm.transaction.transaction.exception.NettyTransactionException;import com.twjitm.transaction.utils.TimeUtil;/** * @author twjitm - [Created on 2018-08-27 10:39] * @company https://github.com/twjitm * @jdk java version "1.8.0_77" */public class NettyTransaction extends AbstractNettyTransaction {    /**     * 创建事务锁等待时间     */    private long waitTime;    /**     * 创建事务实体：     *     * @param cause    事务产生原因     * @param waitTime 等待时间     */    public NettyTransaction(NettyTransactionCause cause, long waitTime) {        super(cause);        this.waitTime = waitTime;    }    /**     * 创建事务实体：     *     * @param cause 事务产生原因     */    public NettyTransaction(NettyTransactionCause cause) {        super(cause);        //默认锁最长等待时间，防止网络延迟，服务器宕机等情况。        this.waitTime = GlobalConstants.Lock.TRAINSTACTION_LOCK_KEY_MAX_LIFE;    }    @Override    public void commit() throws NettyTransactionException {        if (state != TRYCOMMITED) {            throw new NettyTransactionException();        }        this.state = COMMITED;        for (NettyTransactionEntityInterface entity : entities) {            if (!entity.needCommit()) {                continue;            }            entity.commit();        }    }    @Override    public void rollback() throws NettyTransactionException {        state = ROLLEDBACK;        for (NettyTransactionEntityInterface entity : entities) {            entity.rollback();        }    }    @Override    public void tryCommit() throws NettyTransactionException {        if (state != ACTIVE) {            throw new NettyTransactionException();        }        this.state = TRYCOMMITED;        for (NettyTransactionEntityInterface entity : entities) {            if (!entity.needCommit()) {                continue;            }            //重复提交没有成功            NettyTransactionCommitResult transactionCommitResult = entity.tryCommit();            if (!transactionCommitResult.equals(NettyTransactionCommitResult.SUCCESS)) {                this.transactionTryCommitResult = transactionCommitResult;                break;            }        }    }    /**     * 是否可以创建一个分布式事物锁     *     * @return     * @throws NettyTransactionException     */    @Override    public boolean createNettyTransactionLock() throws NettyTransactionException {        if (state != ACTIVE) {            throw new NettyTransactionException();        }        long startSecond = TimeUtil.getSeconds();        boolean createFlag;        if (waitTime > 0) {            while (true) {                long currSeconds = TimeUtil.getSeconds();                createFlag = createNettyTransactionLock(currSeconds);                if (createFlag) {                    break;                }                try {                    Thread.sleep(TimeUtil.SECOND);                } catch (Throwable e) {                }                currSeconds = TimeUtil.getSeconds();                if (startSecond + waitTime < currSeconds) {                    createFlag = false;                    break;                }            }        } else {            startSecond = TimeUtil.getSeconds();            createFlag = createNettyTransactionLock(startSecond);        }        return createFlag;    }    private boolean createNettyTransactionLock(long currSeconds) throws NettyTransactionException {        boolean createFlag = false;        for (NettyTransactionEntityInterface entity : entities) {            try {                createFlag = entity.createNettyTransactionLock(currSeconds);            } catch (Exception e) {                throw new NettyTransactionException(e.getMessage());            }            if (!createFlag) {                break;            }        }        return createFlag;    }    /**     * 释放锁     */    @Override    public void releaseNettyTransactionLock() {        for (NettyTransactionEntityInterface entity : entities) {            entity.releaseNettyTransactionLock();        }    }    @Override    public String toString() {        StringBuffer buffer = new StringBuffer();        buffer.append("transaction ");        buffer.append(getCause());        buffer.append(":");        for (int i = 0; i < entities.size(); i++) {            NettyTransactionEntityInterface entity = entities.get(i);            buffer.append(entity.getInfo());            if (i < entities.size() - 1) {                buffer.append(",");            }        }        return buffer.toString();    }}